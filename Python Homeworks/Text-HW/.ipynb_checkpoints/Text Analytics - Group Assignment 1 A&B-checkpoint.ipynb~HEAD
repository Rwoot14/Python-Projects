{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Text Analytics Group Assignment 1\n",
    "\n",
    "Daxi Cheng, (fill your names here)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Part A (basic text mining)\n",
    "---"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Populating the interactive namespace from numpy and matplotlib\n"
     ]
    }
   ],
   "source": [
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "from pandas import Series, DataFrame\n",
    "import pandas as pd\n",
    "%pylab inline\n",
    "\n",
    "import nltk\n",
    "from nltk import word_tokenize\n",
    "from sklearn.feature_extraction.text import CountVectorizer\n",
    "\n",
    "from nltk.stem import WordNetLemmatizer\n",
    "import re\n",
    "\n",
    "from sklearn.cross_validation import train_test_split\n",
    "from sklearn.naive_bayes import MultinomialNB\n",
    "from sklearn import metrics\n",
    "from sklearn.metrics import classification_report\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A1. What are the top 5 parts of speech in this corpus of job descriptions? How frequently do they appear?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# Read the file and take a subset\n",
    "data=pd.read_csv('Train_rev1.csv')\n",
    "random.seed(1)\n",
    "train_data=data.sample(10000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from nltk.tokenize import sent_tokenize, word_tokenize\n",
    "from collections import Counter\n",
    "from nltk.tokenize import RegexpTokenizer\n",
    "tokenizer = RegexpTokenizer(r'\\w+')\n",
    "def token(s):\n",
    "    decode=s.decode('utf-8').strip()\n",
    "    token=tokenizer.tokenize(decode)\n",
    "    return token\n",
    "train_data['token']=train_data['FullDescription'].map(token)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def pos(s):\n",
    "    poslist=[]\n",
    "    pos=nltk.pos_tag(s)\n",
    "    for i in pos:\n",
    "        poslist.append(i[1])\n",
    "    return poslist\n",
    "train_data['pos']=train_data['token'].map(pos)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "collapsed": true,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import itertools\n",
    "word_list = list(itertools.chain(*train_data['token'].tolist()))\n",
    "lower_list = []\n",
    "#switch all of them to a lower case and make a list\n",
    "for word in word_list:\n",
    "    lower_list.append(word.lower())\n",
    "pos_list = list(itertools.chain(*train_data['pos'].tolist()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('NN', 446329),\n",
       " ('NNP', 359020),\n",
       " ('IN', 257728),\n",
       " ('JJ', 207404),\n",
       " ('DT', 197774)]"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "word_count=Counter(word_list)\n",
    "pos_count=Counter(pos_list)\n",
    "pos_rank=sorted(pos_count.items(),key=lambda x:x[1],reverse=True)\n",
    "pos_rank[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A2. Does this corpus support Zipfâ€™s law? Plot the most common 100 words in the corpus against the theoretical prediction of the law. For this question, do not remove stopwords. Also do not perform stemming or lemmatization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "collapsed": true,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Get the top 100 most frequent words\n",
    "word_freq = Counter(lower_list)\n",
    "top_100=sorted(word_freq.items(),key=lambda x:x[1],reverse=True)[:100]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "rank_freq=[]    \n",
    "for i in top_100:\n",
    "    rank_freq.append(i[1]) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.text.Text at 0x1189a36d0>"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\nhBBCiEL9H4aG5Qp1Lxy6AAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x1212ee610>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Get values for expected frequency of top 100 words using Zipf's Law\n",
    "counter=1\n",
    "zipf=[]\n",
    "max_freq = top_100[0][1]\n",
    "while len(zipf) < 100:\n",
    "    zipf.append(max_freq*1.000/counter)\n",
    "    counter += 1\n",
    "\n",
    "# Plot actual frequencies and Zipf frequencies\n",
    "\n",
    "plt.plot(rank_freq, label = 'Word Frequency')\n",
    "plt.plot(zipf, label = 'Zipf Predicted Frequency') \n",
    "plt.xscale('log')\n",
    "plt.yscale('log')\n",
    "legend(loc='best')\n",
    "xlabel('Log(Rank)')\n",
    "ylabel('Log(Frequency)')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### A3. If we remove stopwords and lemmatize the corpus, what are the 10 most common words? What is their frequency?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from nltk.corpus import stopwords\n",
    "nostop = [word for word in lower_list if word not in stopwords.words('english')]\n",
    "\n",
    "lmtzr = WordNetLemmatizer()\n",
    "nostoplmtzed = [lmtzr.lemmatize(word) for word in nostop]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "experience    17511\n",
       "role          12561\n",
       "team          12374\n",
       "work          12111\n",
       "client        11344\n",
       "business      10837\n",
       "skill          9937\n",
       "service        9924\n",
       "working        8881\n",
       "manager        8698\n",
       "dtype: int64"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pd.Series(nostoplmtzed).value_counts()[:10]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Part B (predict salary from job description)\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### B1. Create a classification model with all words and the bag-of-words approach. How accurate is the model (show the confusion matrix)? "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "partB_data = train_data[['FullDescription', 'SalaryNormalized']]\n",
    "salary_75 = partB_data['SalaryNormalized'].quantile(0.75)\n",
    "partB_data['salary_class'] = np.where(partB_data['SalaryNormalized']>=salary_75,'high','low')\n",
    "x=partB_data['FullDescription']\n",
    "y=partB_data['salary_class']\n",
    "x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = .3, random_state = 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sklearn.feature_extraction.text import CountVectorizer\n",
    "\n",
    "vectorizer = CountVectorizer(analyzer = \"word\", \n",
    "                             tokenizer= None,\n",
    "                             lowercase=True,\n",
    "                             preprocessor = None, \n",
    "                             stop_words = None)\n",
    "\n",
    "X_train = vectorizer.fit_transform(x_train)\n",
    "X_test = vectorizer.transform(x_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from sklearn.naive_bayes import MultinomialNB\n",
    "NB_classifier = MultinomialNB().fit(X_train, y_train)\n",
    "y_nb_predicted = NB_classifier.predict(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Precision:0.585106382979\n",
      "Recall: 0.73726541555\n",
      "Accuracy: 0.804666666667\n"
     ]
    }
   ],
   "source": [
    "from sklearn import metrics\n",
    "print 'Precision:' + str(metrics.precision_score(y_test, y_nb_predicted, average = 'binary', pos_label='high'))\n",
    "print 'Recall: ' + str(metrics.recall_score(y_test, y_nb_predicted, average = 'binary', pos_label='high'))\n",
    "print 'Accuracy: ' + str(metrics.accuracy_score(y_test, y_nb_predicted))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             precision    recall  f1-score   support\n",
      "\n",
      "       high       0.59      0.74      0.65       746\n",
      "        low       0.90      0.83      0.86      2254\n",
      "\n",
      "avg / total       0.83      0.80      0.81      3000\n",
      "\n"
     ]
    }
   ],
   "source": [
    "print classification_report(y_test,y_nb_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 550  196]\n",
      " [ 390 1864]]\n"
     ]
    }
   ],
   "source": [
    "# Print confusion matrix for NB with tokenization\n",
    "print metrics.confusion_matrix(y_test, y_nb_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.804666666667\n"
     ]
    }
   ],
   "source": [
    "# Get accuracy score for tokenization\n",
    "print metrics.accuracy_score(y_test, y_nb_predicted)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### B2. Speculate before running the following analysis whether lemmatization would help improve the accuracy of classification. Now create a classification model after lemmatization. Did the classification accuracy increase relative to B1? Comment on your speculation versus the actual results you obtained."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "lemmatizer=WordNetLemmatizer()\n",
    "tokenizer = RegexpTokenizer(r'\\w+')\n",
    "def lemtokenize(text):\n",
    "    tokens = tokenizer.tokenize(text)\n",
    "    lemmas = []\n",
    "    for item in tokens:\n",
    "        lower=item.lower()\n",
    "        lemmas.append(lemmatizer.lemmatize(lower))\n",
    "    return lemmas"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "vectorizer = CountVectorizer(analyzer = \"word\", \n",
    "                             tokenizer= lemtokenize,\n",
    "                             preprocessor = None, \n",
    "                             stop_words = None, \n",
    "                             max_features = None)\n",
    "\n",
    "X_train = vectorizer.fit_transform(x_train)\n",
    "X_test = vectorizer.transform(x_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             precision    recall  f1-score   support\n",
      "\n",
      "       high       0.58      0.73      0.65       746\n",
      "        low       0.90      0.83      0.86      2254\n",
      "\n",
      "avg / total       0.82      0.80      0.81      3000\n",
      "\n"
     ]
    }
   ],
   "source": [
    "NB_lem_classifier = MultinomialNB().fit(X_train, y_train)\n",
    "y_nb_lem_predicted = NB_lem_classifier.predict(X_test)\n",
    "print classification_report(y_test,y_nb_lem_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 546  200]\n",
      " [ 394 1860]]\n"
     ]
    }
   ],
   "source": [
    "# Print confusion matrix for NB with tokenization\n",
    "print metrics.confusion_matrix(y_test, y_nb_lem_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.802\n"
     ]
    }
   ],
   "source": [
    "# Get accuracy score for tokenization\n",
    "print metrics.accuracy_score(y_test, y_nb_lem_predicted)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### B3. Now speculate whether stopwords removal from the original data would help increase the accuracy of the model. Take out the stopwords (but do not lemmatize), build a classification model and check the accuracy, and compare with that in B1 & B2.   Also show the top 10 words (excluding stopwords) that are most indicative of (i) high salary, and (ii) low salary. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "vectorizer = CountVectorizer(analyzer = \"word\", \n",
    "                             tokenizer= tokenizer.tokenize,\n",
    "                             preprocessor = None, \n",
    "                             stop_words = 'english', \n",
    "                             max_features = None)\n",
    "\n",
    "X_train = vectorizer.fit_transform(x_train)\n",
    "X_test = vectorizer.transform(x_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             precision    recall  f1-score   support\n",
      "\n",
      "       high       0.59      0.75      0.66       746\n",
      "        low       0.91      0.82      0.87      2254\n",
      "\n",
      "avg / total       0.83      0.81      0.81      3000\n",
      "\n"
     ]
    }
   ],
   "source": [
    "NB_nsw_classifier = MultinomialNB().fit(X_train, y_train)\n",
    "y_nb_nsw_predicted = NB_nsw_classifier.predict(X_test)\n",
    "print classification_report(y_test,y_nb_nsw_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 563  183]\n",
      " [ 395 1859]]\n"
     ]
    }
   ],
   "source": [
    "# Print confusion matrix for NB with tokenization\n",
    "print metrics.confusion_matrix(y_test, y_nb_nsw_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.807333333333\n"
     ]
    }
   ],
   "source": [
    "# Get accuracy score for tokenization\n",
    "print metrics.accuracy_score(y_test, y_nb_nsw_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "low top 10:\n",
      "development, working, client, skills, work, management, team, role, business, experience\n",
      "high top 10:\n",
      "manager, client, business, sales, working, skills, team, role, work, experience\n"
     ]
    }
   ],
   "source": [
    "from operator import itemgetter\n",
    "N = 10\n",
    "vocabulary = np.array([t for t, i in sorted(vectorizer.vocabulary_.iteritems(), key=itemgetter(1))])\n",
    "for i in range(2):\n",
    "    topN = np.argsort(NB_nsw_classifier.feature_log_prob_[i])[-10:]\n",
    "    print y.value_counts().index[i] + \" top 10:\"\n",
    "    print \", \".join(vocabulary[topN])\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### B4.  Use the job descriptions without lemmatization and stopword removal. Add parts-of-speech bigrams to the bag-of-words, and run a new classification model. Does the accuracy increase over the results in B1? "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "179687    NNPNNP, NNPNNP, NNPVB, VBNNP, NNPNN, NNVBP, VB...\n",
       "18497     NNPNNP, NNPNNP, NNPNNP, NNPNNP, NNPNNP, NNPCC,...\n",
       "86382     JJNNP, NNPNNP, NNPCD, CDNNS, NNSNNP, NNPNNP, N...\n",
       "12805     NNNNP, NNPNNP, NNPNNP, NNPNN, NNTO, TOVB, VBIN...\n",
       "203497    NNPNNP, NNPNNP, NNPNNP, NNPNNP, NNPNNP, NNPNNP...\n",
       "Name: bipos, dtype: object"
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from nltk.util import ngrams\n",
    "def posbigram(s):\n",
    "    bigramlist=[]\n",
    "    bigrams=ngrams(s,2)\n",
    "    for i in bigrams:\n",
    "        aux=str(i).lstrip('(').rstrip(')')\n",
    "        bigram=aux.replace(',','')\n",
    "        bigram=bigram.replace(\"'\",\"\")\n",
    "        bigram=bigram.replace(' ','')\n",
    "        bigramlist.append(bigram)\n",
    "    return str(bigramlist).strip('[').rstrip(']').replace(\"'\",\"\")\n",
    "train_data['bipos']=train_data['pos'].map(posbigram)\n",
    "train_data['bipos'].head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "179687    SAS Administrator  London  ****k My client, ar...\n",
       "18497     Job Title: Retail Director Location: Midlands ...\n",
       "86382     Private Client Solicitor  2 years PQE  East Gr...\n",
       "12805     ****mh**** Devon & Cornwall Excellent opportun...\n",
       "203497    Position: White Goods/Domestic Appliance Engin...\n",
       "Name: newfeature, dtype: object"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_data['newfeature']=train_data['FullDescription']+train_data['bipos']\n",
    "train_data['newfeature'].head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "train_data['newfeature']=train_data['FullDescription']+train_data['bipos']\n",
    "partB_data = train_data[['newfeature','SalaryNormalized']]\n",
    "salary_75 = partB_data['SalaryNormalized'].quantile(0.75)\n",
    "partB_data['salary_class'] = np.where(partB_data['SalaryNormalized']>=salary_75,'high','low')\n",
    "x=partB_data['newfeature']\n",
    "y=partB_data['salary_class']\n",
    "x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = .3, random_state = 1)\n",
    "vectorizer = CountVectorizer(analyzer = \"word\", \n",
    "                             tokenizer= tokenizer.tokenize,\n",
    "                             preprocessor = None, \n",
    "                             stop_words = None, \n",
    "                             max_features = None)\n",
    "\n",
    "X_train = vectorizer.fit_transform(x_train)\n",
    "X_test = vectorizer.transform(x_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             precision    recall  f1-score   support\n",
      "\n",
      "       high       0.58      0.71      0.64       746\n",
      "        low       0.90      0.83      0.86      2254\n",
      "\n",
      "avg / total       0.82      0.80      0.81      3000\n",
      "\n"
     ]
    }
   ],
   "source": [
    "NB_posbi_classifier = MultinomialNB().fit(X_train, y_train)\n",
    "y_nb_posbi_predicted = NB_posbi_classifier.predict(X_test)\n",
    "print classification_report(y_test,y_nb_posbi_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 531  215]\n",
      " [ 389 1865]]\n"
     ]
    }
   ],
   "source": [
    "# Print confusion matrix for NB with tokenization\n",
    "print metrics.confusion_matrix(y_test, y_nb_posbi_predicted)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.798666666667\n"
     ]
    }
   ],
   "source": [
    "# Get accuracy score for tokenization\n",
    "print metrics.accuracy_score(y_test, y_nb_posbi_predicted)"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
